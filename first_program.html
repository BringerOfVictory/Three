<!DOCTYPE html>

<html>

<head>
<title>Three.js Funsies</title>
<script
src="./three.min.js"></script>
<style>
body{
/* set margin to 0 and overflow to hidden, 
to use the complete page */

margin: 0;
overflow: hidden;
}
</style>
</head>
<body>


<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">
	var t3 = THREE;

	var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
    camera.position.set(50, -50, 50);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    var scene = new THREE.Scene();
    renderer.setClearColor(0xffffff, 1);
	
	var light = new THREE.PointLight( 0xffffff, 1, 400 );
	light.position.set( 10, 10, 80 );
	scene.add( light );

	charge1 = new PointCharge(scene, -10, -10, 0, 5, 10);
	charge2 = new PointCharge(scene, 10, 10, 0, 5, 10);
	scene.add(make_curve())

	// make_arrow(scene, new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0), 10);

	make_electric_field(scene, [charge1, charge2]);

	// scene.add(new THREE.Mesh(new THREE.TetrahedronGeometry(4, 0), new THREE.MeshLambertMaterial({color: 0xff66cc})))

	console.log(camera.rotation)
	camera.rotation.z = 0.5
	console.log(camera.rotation)

	function make_electric_field(s, charges) {
		var k = 1;
		for (x = -15; x <= 15; x += 5) {
			for (y = -15; y <= 15; y += 5) {
				for (z = -5; z <= 10; z += 5) {
					pos = new THREE.Vector3(x, y, z);
					net_field = new THREE.Vector3(0, 0, 0);
					for (i = 0; i < charges.length; i++) {
						var r = new THREE.Vector3();
						r.subVectors(pos, charges[i].vec);
						var mag_r = r.length();
						var e = k * charges[i].charge / mag_r / mag_r / mag_r;
						r.multiplyScalar(e);
						net_field.add(e);
					}
					var e = net_field.length();
					net_field.normalize();
					make_arrow(s, pos, net_field, e * 100);
				}
			}
		}
	}

	function make_arrow(s, origin, dir, length) {
		// var dir = new THREE.Vector3( 1, 0, 0 );
		// var origin = new THREE.Vector3( 0, 0, 0 );
		// var length = 10;
		var hex = 0xff66cc;

		var arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
		s.add( arrowHelper );
	}

	function PointCharge(s, x0, y0, z0, r, q) {
		this.scene = s;
		this.x0 = x0;
		this.y0 = y0;
		this.z0 = z0;
		this.vec = new THREE.Vector3(x0, y0, z0);
		this.radius = r
		this.charge = q
		make_axes(scene, r * 2, x0, y0, z0);
		make_sphere(scene, r, x0, y0, z0);
	}

	function make_curve() {
		var curve = new THREE.QuadraticBezierCurve3(
		new THREE.Vector3(-10, -10, 0),
		new THREE.Vector3(0, 0, 50),
		new THREE.Vector3(10, 10, 0)
		);

		var path = new THREE.Path( curve.getPoints( 50 ) );

		var geometry = path.createPointsGeometry( 50 );
		geometry.vertices = curve.getPoints(50);
		var material = new THREE.LineBasicMaterial( { color : 0xff0000 } );

		//Create the final Object3d to add to the scene
		// var curveObject = new THREE.Line( geometry, material );
		return new THREE.Line(geometry, material);
	}

	function make_sphere(s, r, x0, y0, z0) {
		var s_geometry = new THREE.SphereGeometry( 5, 32, 32 );
		var s_material = new THREE.MeshLambertMaterial( {color: 0xcc66ff} );
		var sphere = new THREE.Mesh( s_geometry, s_material );
		sphere.position.set(x0, y0, z0);
		s.add( sphere );
	}
    // renderer.render(scene, camera);
    function make_axes(s, r, x0, y0, z0) {
    	var g = new THREE.Geometry();

    	var material = new THREE.LineBasicMaterial({
	        color: 0x0000ff
	    });

	    var line = new THREE.Line(g, material);

    	add_spoke(g, x0 + r, y0, z0, x0, y0, z0);
	    add_spoke(g, x0 - r, y0, z0, x0, y0, z0);
	    add_spoke(g, x0, y0 + r, z0, x0, y0, z0);
	    add_spoke(g, x0, y0 - r, z0, x0, y0, z0);
	    add_spoke(g, x0, y0, z0 + r, x0, y0, z0);
	    add_spoke(g, x0, y0, z0 - r, x0, y0, z0);

	    s.add(line);
    }

    function add_spoke(geometry, x, y, z, x0, y0, z0) {
		geometry.vertices.push(new THREE.Vector3(x, y, z));
		geometry.vertices.push(new THREE.Vector3(x0, y0, z0));
	}

	var theta = 0;
	var render = function () {
		requestAnimationFrame( render );

		theta += 0.05;
		// camera.position.x = 2 * 10 * Math.cos(theta);
		// camera.position.y = 2 * 10 * Math.sin(theta);

		// camera.lookAt(new THREE.Vector3(0, 0, 0));

		renderer.render(scene, camera);
	};

	render();
	// var theta = 0;
	// return function () {
	// 	theta += 0.1;
	// 	camera.position.x = 2 * r * Math.cos(theta);
	// 	camera.position.y = 2 * r * Math.sin(theta); 
	// }




	// var light = new t3.PointLight();
	// light.position.set(2, 1, 1);
	// scene.add(light);

	// var makeCube = function (x, y, z) {
	// 	var cube = new t3.Mesh(
	// 		new t3.BoxGeometry(1, 1.1, 1),
	// 		new t3.MeshLambertMaterial(
	// 			{color: 'red'})
	// 	);
	// 	cube.position.set(0, 0, 0).add(
	// 	new t3.Vector3(x, y, z));
	// 	scene.add(cube);
	// 	return cube;
	// };

	// var cubes = []
	// for (var i = 0; i < 3; i ++) {
	// 	cubes[i] = makeCube(0, 1 + 1.2 * i, 3);
	// }
	// var k = 0;
	// return function () {
	// 	k += -0.02;
	// 	for (var i = 0; i < cubes.length; i++) {
	// 		cubes[i].rotation.y = k;
	// 		cubes[i].position.z += 0.05
	// 	}
	// };

</script>
</body>
</html>